;
; File generated by cc65 v 2.18 - Git dc4142e
;
	.fopt		compiler,"cc65 v 2.18 - Git dc4142e"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_pal_bg
	.import		_pal_spr
	.import		_pal_bright
	.import		_ppu_wait_nmi
	.import		_ppu_off
	.import		_ppu_on_all
	.import		_oam_clear
	.import		_oam_spr
	.import		_pad_poll
	.import		_scroll
	.import		_bank_spr
	.import		_rand8
	.import		_vram_adr
	.import		_vram_write
	.import		_vram_unrle
	.import		_memcpy
	.import		_memfill
	.import		_delay
	.import		_set_vram_buffer
	.import		_one_vram_buffer
	.import		_multi_vram_buffer_horz
	.import		_multi_vram_buffer_vert
	.import		_clear_vram_buffer
	.import		_get_pad_new
	.import		_get_ppu_addr
	.import		_seed_rng
	.export		_RoundSprL
	.export		_RoundSprR
	.export		_game_area
	.export		_tick_count
	.export		_pad1
	.export		_pad1_new
	.export		_text
	.export		_state
	.export		_cur_block
	.export		_fall_rate
	.export		_def_z_clust
	.export		_def_z_rev_clust
	.export		_def_line_clust
	.export		_def_box_clust
	.export		_def_tee_clust
	.export		_def_L_clust
	.export		_def_L_rev_clust
	.export		_cluster_defs
	.export		_cur_rot
	.export		_cur_cluster
	.export		_next_cluster
	.export		_cluster_sprites
	.export		_cluster_offsets
	.export		_horz_button_delay
	.export		_button_delay
	.export		_require_new_down_button
	.export		_fall_frame_counter
	.export		_lines_cleared_one
	.export		_lines_cleared_ten
	.export		_lines_cleared_hundred
	.export		_cur_nt
	.export		_off_nt
	.export		_hit
	.export		_temp_fall_rate
	.export		_old_x
	.export		_id
	.export		_min_y
	.export		_max_y
	.export		_game_board
	.export		_game_board_temp
	.export		_empty_row
	.export		_full_row
	.export		_full_col
	.export		_copy_board_data
	.export		_lines_cleared_y
	.export		_palette_bg
	.export		_palette_sp
	.export		_draw_sprites
	.export		_movement
	.export		_set_block
	.export		_set_block_nt
	.export		_clear_block
	.export		_put_cur_cluster
	.export		_get_block
	.export		_is_block_free
	.export		_is_cluster_colliding
	.export		_spawn_new_cluster
	.export		_rotate_cur_cluster
	.export		_go_to_state
	.export		_inc_lines_cleared
	.export		_display_lines_cleared
	.export		_try_collapse_board_data
	.export		_try_collapse_empty_row_data
	.export		_reveal_empty_rows_to_nt
	.export		_copy_board_to_nt
	.export		_debug_fill_nametables
	.export		_debug_draw_board_area
	.export		_debug_copy_board_data_to_nt
	.export		_debug_display_number
	.export		_main

.segment	"DATA"

_state:
	.byte	$00
_cur_block:
	.byte	$00
	.byte	$00
_fall_rate:
	.byte	$0A
_cluster_defs:
	.addr	_def_z_clust
	.addr	_def_z_rev_clust
	.addr	_def_line_clust
	.addr	_def_box_clust
	.addr	_def_tee_clust
	.addr	_def_L_clust
	.addr	_def_L_rev_clust
_cluster_sprites:
	.byte	$10
	.byte	$11
	.byte	$12
	.byte	$13
	.byte	$14
	.byte	$15
	.byte	$16
_cluster_offsets:
	.byte	$03
	.byte	$03
	.byte	$02
	.byte	$03
	.byte	$04
	.byte	$03
	.byte	$03
_empty_row:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_full_row:
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
_full_col:
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01

.segment	"RODATA"

_RoundSprL:
	.byte	$FF
	.byte	$FF
	.byte	$02
	.byte	$00
	.byte	$07
	.byte	$FF
	.byte	$03
	.byte	$00
	.byte	$FF
	.byte	$07
	.byte	$12
	.byte	$00
	.byte	$07
	.byte	$07
	.byte	$13
	.byte	$00
	.byte	$80
_RoundSprR:
	.byte	$FF
	.byte	$FF
	.byte	$00
	.byte	$00
	.byte	$07
	.byte	$FF
	.byte	$01
	.byte	$00
	.byte	$FF
	.byte	$07
	.byte	$10
	.byte	$00
	.byte	$07
	.byte	$07
	.byte	$11
	.byte	$00
	.byte	$80
_game_area:
	.byte	$01
	.byte	$00
	.byte	$01
	.byte	$16
	.byte	$B2
	.byte	$E7
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$A4
	.byte	$A5
	.byte	$A6
	.byte	$00
	.byte	$01
	.byte	$08
	.byte	$E4
	.byte	$E7
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$E4
	.byte	$C9
	.byte	$F7
	.byte	$00
	.byte	$B2
	.byte	$B3
	.byte	$B4
	.byte	$B5
	.byte	$B6
	.byte	$B7
	.byte	$00
	.byte	$A4
	.byte	$A5
	.byte	$A6
	.byte	$00
	.byte	$01
	.byte	$03
	.byte	$87
	.byte	$89
	.byte	$88
	.byte	$8B
	.byte	$A5
	.byte	$00
	.byte	$01
	.byte	$07
	.byte	$C0
	.byte	$87
	.byte	$8A
	.byte	$88
	.byte	$8B
	.byte	$C2
	.byte	$C3
	.byte	$C4
	.byte	$C5
	.byte	$C6
	.byte	$C7
	.byte	$B3
	.byte	$B4
	.byte	$B5
	.byte	$B6
	.byte	$B7
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$80
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$D2
	.byte	$D3
	.byte	$D4
	.byte	$D5
	.byte	$D6
	.byte	$D7
	.byte	$C3
	.byte	$C4
	.byte	$C5
	.byte	$C6
	.byte	$C7
	.byte	$00
	.byte	$00
	.byte	$E4
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$99
	.byte	$98
	.byte	$9B
	.byte	$E6
	.byte	$E7
	.byte	$00
	.byte	$01
	.byte	$03
	.byte	$D3
	.byte	$D4
	.byte	$D5
	.byte	$D6
	.byte	$D7
	.byte	$00
	.byte	$00
	.byte	$F4
	.byte	$97
	.byte	$A8
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$B1
	.byte	$B1
	.byte	$E6
	.byte	$E7
	.byte	$00
	.byte	$01
	.byte	$08
	.byte	$D8
	.byte	$97
	.byte	$A9
	.byte	$AA
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$A7
	.byte	$A8
	.byte	$98
	.byte	$9B
	.byte	$F5
	.byte	$B1
	.byte	$E8
	.byte	$F7
	.byte	$00
	.byte	$01
	.byte	$08
	.byte	$D0
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$C9
	.byte	$E8
	.byte	$F6
	.byte	$F7
	.byte	$00
	.byte	$01
	.byte	$07
	.byte	$A4
	.byte	$A5
	.byte	$A7
	.byte	$A8
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$D9
	.byte	$F8
	.byte	$F9
	.byte	$A3
	.byte	$00
	.byte	$01
	.byte	$05
	.byte	$B2
	.byte	$B3
	.byte	$B4
	.byte	$B4
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$A9
	.byte	$98
	.byte	$9B
	.byte	$A2
	.byte	$A2
	.byte	$EA
	.byte	$FA
	.byte	$00
	.byte	$01
	.byte	$04
	.byte	$E4
	.byte	$F5
	.byte	$B4
	.byte	$E8
	.byte	$F6
	.byte	$97
	.byte	$99
	.byte	$98
	.byte	$BB
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$98
	.byte	$9A
	.byte	$9B
	.byte	$E2
	.byte	$E3
	.byte	$00
	.byte	$01
	.byte	$06
	.byte	$F4
	.byte	$C9
	.byte	$F6
	.byte	$F6
	.byte	$B4
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$F2
	.byte	$F3
	.byte	$00
	.byte	$01
	.byte	$06
	.byte	$D0
	.byte	$C2
	.byte	$C3
	.byte	$C4
	.byte	$C5
	.byte	$A7
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$A7
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$E2
	.byte	$E3
	.byte	$00
	.byte	$01
	.byte	$07
	.byte	$EA
	.byte	$D1
	.byte	$D3
	.byte	$D3
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$B8
	.byte	$98
	.byte	$9B
	.byte	$E2
	.byte	$F3
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$E0
	.byte	$E1
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$83
	.byte	$84
	.byte	$85
	.byte	$86
	.byte	$00
	.byte	$01
	.byte	$07
	.byte	$F0
	.byte	$F1
	.byte	$97
	.byte	$B8
	.byte	$98
	.byte	$BB
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$93
	.byte	$94
	.byte	$95
	.byte	$96
	.byte	$00
	.byte	$01
	.byte	$07
	.byte	$F2
	.byte	$E3
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$B9
	.byte	$BA
	.byte	$9B
	.byte	$87
	.byte	$8B
	.byte	$97
	.byte	$FA
	.byte	$9D
	.byte	$00
	.byte	$C7
	.byte	$00
	.byte	$00
	.byte	$A4
	.byte	$A5
	.byte	$00
	.byte	$E2
	.byte	$E3
	.byte	$A7
	.byte	$98
	.byte	$99
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$FA
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$AD
	.byte	$00
	.byte	$80
	.byte	$01
	.byte	$02
	.byte	$90
	.byte	$82
	.byte	$84
	.byte	$85
	.byte	$84
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$BC
	.byte	$BD
	.byte	$BE
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$A1
	.byte	$92
	.byte	$94
	.byte	$95
	.byte	$94
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$CC
	.byte	$CD
	.byte	$CE
	.byte	$00
	.byte	$01
	.byte	$03
	.byte	$97
	.byte	$9A
	.byte	$98
	.byte	$99
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$BB
	.byte	$00
	.byte	$00
	.byte	$DB
	.byte	$DC
	.byte	$DD
	.byte	$DE
	.byte	$9E
	.byte	$9F
	.byte	$00
	.byte	$00
	.byte	$A7
	.byte	$98
	.byte	$98
	.byte	$99
	.byte	$97
	.byte	$9A
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$00
	.byte	$EB
	.byte	$EC
	.byte	$ED
	.byte	$EE
	.byte	$AE
	.byte	$AF
	.byte	$8C
	.byte	$8C
	.byte	$97
	.byte	$A8
	.byte	$98
	.byte	$B9
	.byte	$97
	.byte	$B8
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$8C
	.byte	$BF
	.byte	$FB
	.byte	$FC
	.byte	$FD
	.byte	$FE
	.byte	$8C
	.byte	$01
	.byte	$03
	.byte	$97
	.byte	$98
	.byte	$01
	.byte	$02
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$A7
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$CF
	.byte	$8C
	.byte	$8C
	.byte	$CF
	.byte	$8C
	.byte	$8C
	.byte	$8E
	.byte	$01
	.byte	$03
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$A9
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$AB
	.byte	$82
	.byte	$83
	.byte	$84
	.byte	$85
	.byte	$84
	.byte	$85
	.byte	$83
	.byte	$84
	.byte	$85
	.byte	$86
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$8E
	.byte	$8F
	.byte	$8C
	.byte	$01
	.byte	$07
	.byte	$97
	.byte	$B8
	.byte	$98
	.byte	$98
	.byte	$97
	.byte	$98
	.byte	$9A
	.byte	$9B
	.byte	$92
	.byte	$93
	.byte	$94
	.byte	$95
	.byte	$94
	.byte	$95
	.byte	$93
	.byte	$94
	.byte	$95
	.byte	$96
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$8C
	.byte	$01
	.byte	$09
	.byte	$8D
	.byte	$8E
	.byte	$01
	.byte	$02
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$8D
	.byte	$8E
	.byte	$01
	.byte	$07
	.byte	$8F
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$8C
	.byte	$01
	.byte	$06
	.byte	$BF
	.byte	$8C
	.byte	$01
	.byte	$05
	.byte	$97
	.byte	$98
	.byte	$98
	.byte	$8C
	.byte	$01
	.byte	$0B
	.byte	$98
	.byte	$98
	.byte	$9B
	.byte	$8C
	.byte	$01
	.byte	$04
	.byte	$AE
	.byte	$8C
	.byte	$01
	.byte	$07
	.byte	$8D
	.byte	$8E
	.byte	$8E
	.byte	$8F
	.byte	$8C
	.byte	$01
	.byte	$09
	.byte	$8D
	.byte	$8E
	.byte	$8E
	.byte	$8F
	.byte	$8C
	.byte	$01
	.byte	$03
	.byte	$BF
	.byte	$8C
	.byte	$01
	.byte	$20
	.byte	$55
	.byte	$55
	.byte	$A7
	.byte	$F5
	.byte	$F5
	.byte	$BD
	.byte	$67
	.byte	$55
	.byte	$55
	.byte	$DD
	.byte	$AA
	.byte	$00
	.byte	$00
	.byte	$88
	.byte	$EE
	.byte	$77
	.byte	$D5
	.byte	$FF
	.byte	$AA
	.byte	$00
	.byte	$00
	.byte	$88
	.byte	$EE
	.byte	$57
	.byte	$5D
	.byte	$DF
	.byte	$AA
	.byte	$00
	.byte	$00
	.byte	$88
	.byte	$EE
	.byte	$75
	.byte	$FF
	.byte	$FF
	.byte	$AA
	.byte	$00
	.byte	$00
	.byte	$88
	.byte	$AA
	.byte	$56
	.byte	$51
	.byte	$AA
	.byte	$AA
	.byte	$00
	.byte	$00
	.byte	$88
	.byte	$66
	.byte	$55
	.byte	$55
	.byte	$5A
	.byte	$AA
	.byte	$5F
	.byte	$5F
	.byte	$9B
	.byte	$66
	.byte	$55
	.byte	$05
	.byte	$01
	.byte	$06
	.byte	$05
	.byte	$01
	.byte	$00
_text:
	.byte	$2D,$20,$50,$52,$45,$53,$53,$20,$53,$54,$41,$52,$54,$20,$2D,$00
_def_z_clust:
	.word	$0C60
	.word	$0264
	.word	$0C60
	.word	$0264
_def_z_rev_clust:
	.word	$06C0
	.word	$8C40
	.word	$06C0
	.word	$8C40
_def_line_clust:
	.word	$00F0
	.word	$4444
	.word	$00F0
	.word	$4444
_def_box_clust:
	.word	$0660
	.word	$0660
	.word	$0660
	.word	$0660
_def_tee_clust:
	.word	$4E00
	.word	$4640
	.word	$0E40
	.word	$4C40
_def_L_clust:
	.word	$0E80
	.word	$C440
	.word	$2E00
	.word	$4460
_def_L_rev_clust:
	.word	$0E20
	.word	$44C0
	.word	$8E00
	.word	$6440
_button_delay:
	.byte	$05
_palette_bg:
	.byte	$3C
	.byte	$01
	.byte	$21
	.byte	$30
	.byte	$3C
	.byte	$22
	.byte	$01
	.byte	$30
	.byte	$3C
	.byte	$0F
	.byte	$1D
	.byte	$22
	.byte	$3C
	.byte	$0F
	.byte	$26
	.byte	$29
_palette_sp:
	.byte	$3C
	.byte	$01
	.byte	$21
	.byte	$30
	.byte	$0F
	.byte	$09
	.byte	$19
	.byte	$29
	.byte	$0F
	.byte	$07
	.byte	$28
	.byte	$38
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
L0585:
	.byte	$47,$41,$4D,$45,$20,$4F,$56,$45,$52,$21,$00

.segment	"BSS"

.segment	"ZEROPAGE"
_tick_count:
	.res	1,$00
_pad1:
	.res	1,$00
_pad1_new:
	.res	1,$00
_cur_rot:
	.res	1,$00
_cur_cluster:
	.res	6,$00
_next_cluster:
	.res	6,$00
_horz_button_delay:
	.res	1,$00
_require_new_down_button:
	.res	1,$00
_fall_frame_counter:
	.res	1,$00
_lines_cleared_one:
	.res	1,$00
_lines_cleared_ten:
	.res	1,$00
_lines_cleared_hundred:
	.res	1,$00
_cur_nt:
	.res	1,$00
_off_nt:
	.res	1,$00
_hit:
	.res	1,$00
_temp_fall_rate:
	.res	1,$00
_old_x:
	.res	1,$00
_id:
	.res	1,$00
_min_y:
	.res	1,$00
_max_y:
	.res	1,$00
.segment	"BSS"
_game_board:
	.res	240,$00
_game_board_temp:
	.res	240,$00
_copy_board_data:
	.res	20,$00
_lines_cleared_y:
	.res	4,$00

; ---------------------------------------------------------------
; void __near__ draw_sprites (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_sprites: near

.segment	"CODE"

;
; oam_clear();
;
	jsr     decsp4
	jsr     _oam_clear
;
; start_x = (cur_block.x << 3) + BOARD_START_X_PX;
;
	lda     _cur_block
	asl     a
	asl     a
	asl     a
	clc
	adc     #$60
	ldy     #$03
	sta     (sp),y
;
; start_y = (cur_block.y << 3) + BOARD_START_Y_PX;
;
	lda     _cur_block+1
	asl     a
	asl     a
	asl     a
	dey
	sta     (sp),y
;
; if (cur_block.y != 255)
;
	lda     _cur_block+1
	cmp     #$FF
	jeq     L06BE
;
; for (iy = 0; iy < 4; ++iy)
;
	lda     #$00
	tay
L06BB:	sta     (sp),y
	cmp     #$04
	jcs     L06BE
;
; for (ix = 0; ix < 4; ++ix)
;
	tya
	iny
L06BA:	sta     (sp),y
	cmp     #$04
	jcs     L03C2
;
; unsigned char bit = ((iy * 4) + (ix & 3)); // &3 = %4
;
	dey
	lda     (sp),y
	asl     a
	asl     a
	sta     ptr1
	iny
	lda     (sp),y
	and     #$03
	clc
	adc     ptr1
	jsr     pusha
;
; if (cur_cluster.layout & (0x8000 >> bit))
;
	ldy     #$00
	lda     (sp),y
	tay
	lda     #$00
	ldx     #$80
	jsr     shraxy
	and     _cur_cluster
	pha
	txa
	and     _cur_cluster+1
	sta     tmp1
	pla
	ora     tmp1
	beq     L03D7
;
; if (start_y + (iy << 3) > (BOARD_START_Y_PX + (BOARD_OOB_END << 3)))
;
	ldx     #$00
	ldy     #$01
	lda     (sp),y
	jsr     aslax3
	clc
	ldy     #$03
	adc     (sp),y
	bcc     L06B5
	inx
L06B5:	cmp     #$19
	txa
	sbc     #$00
	bcc     L03D7
;
; oam_spr(start_x + (ix << 3), start_y + (iy << 3), cur_cluster.sprite, 0);
;
	jsr     decsp3
	ldy     #$05
	lda     (sp),y
	asl     a
	asl     a
	asl     a
	clc
	ldy     #$07
	adc     (sp),y
	ldy     #$02
	sta     (sp),y
	ldy     #$04
	lda     (sp),y
	asl     a
	asl     a
	asl     a
	clc
	ldy     #$06
	adc     (sp),y
	ldy     #$01
	sta     (sp),y
	lda     _cur_cluster+4
	dey
	sta     (sp),y
	tya
	jsr     _oam_spr
;
; }
;
L03D7:	jsr     incsp1
;
; for (ix = 0; ix < 4; ++ix)
;
	ldy     #$01
	clc
	tya
	adc     (sp),y
	jmp     L06BA
;
; for (iy = 0; iy < 4; ++iy)
;
L03C2:	dey
	clc
	lda     #$01
	adc     (sp),y
	jmp     L06BB
;
; start_x = 15 << 3;
;
L06BE:	lda     #$78
	ldy     #$03
	sta     (sp),y
;
; start_y = 0 << 3;
;
	lda     #$00
	dey
	sta     (sp),y
;
; for (iy = 0; iy < 4; ++iy)
;
	tay
L06BD:	sta     (sp),y
	cmp     #$04
	bcs     L03E8
;
; for (ix = 0; ix < 4; ++ix)
;
	tya
	iny
L06BC:	sta     (sp),y
	cmp     #$04
	bcs     L03E9
;
; unsigned char bit = ((iy * 4) + (ix & 3)); // &3 = %4
;
	dey
	lda     (sp),y
	asl     a
	asl     a
	sta     ptr1
	iny
	lda     (sp),y
	and     #$03
	clc
	adc     ptr1
	jsr     pusha
;
; if (next_cluster.layout & (0x8000 >> bit))
;
	ldy     #$00
	lda     (sp),y
	tay
	lda     #$00
	ldx     #$80
	jsr     shraxy
	and     _next_cluster
	pha
	txa
	and     _next_cluster+1
	sta     tmp1
	pla
	ora     tmp1
	beq     L03FB
;
; oam_spr(start_x + (ix << 3), start_y + (iy << 3), next_cluster.sprite, 0);
;
	jsr     decsp3
	ldy     #$05
	lda     (sp),y
	asl     a
	asl     a
	asl     a
	clc
	ldy     #$07
	adc     (sp),y
	ldy     #$02
	sta     (sp),y
	ldy     #$04
	lda     (sp),y
	asl     a
	asl     a
	asl     a
	clc
	ldy     #$06
	adc     (sp),y
	ldy     #$01
	sta     (sp),y
	lda     _next_cluster+4
	dey
	sta     (sp),y
	tya
	jsr     _oam_spr
;
; }
;
L03FB:	jsr     incsp1
;
; for (ix = 0; ix < 4; ++ix)
;
	ldy     #$01
	clc
	tya
	adc     (sp),y
	jmp     L06BC
;
; for (iy = 0; iy < 4; ++iy)
;
L03E9:	dey
	clc
	lda     #$01
	adc     (sp),y
	jmp     L06BD
;
; }
;
L03E8:	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ movement (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_movement: near

.segment	"CODE"

;
; hit = 0;
;
	lda     #$00
	sta     _hit
;
; temp_fall_rate = 0;
;
	sta     _temp_fall_rate
;
; old_x = 0;
;
	sta     _old_x
;
; ++fall_frame_counter;
;
	inc     _fall_frame_counter
;
; if (pad1_new & PAD_A)
;
	lda     _pad1_new
	and     #$80
	beq     L06C7
;
; rotate_cur_cluster(1);
;
	lda     #$01
;
; else if (pad1_new & PAD_B)
;
	jmp     L06C4
L06C7:	lda     _pad1_new
	and     #$40
	beq     L06C8
;
; rotate_cur_cluster(-1);
;
	lda     #$FF
L06C4:	jsr     _rotate_cur_cluster
;
; --horz_button_delay;
;
L06C8:	dec     _horz_button_delay
;
; old_x = cur_block.x;
;
	lda     _cur_block
	sta     _old_x
;
; if (((pad1 & PAD_RIGHT) && horz_button_delay == 0) || (pad1_new & PAD_RIGHT))
;
	lda     _pad1
	and     #$01
	beq     L06CC
	lda     _horz_button_delay
	beq     L06CF
L06CC:	lda     _pad1_new
	and     #$01
	beq     L06D1
;
; horz_button_delay = button_delay;
;
L06CF:	lda     _button_delay
	sta     _horz_button_delay
;
; if ((pad1_new & PAD_RIGHT))
;
	lda     _pad1_new
	and     #$01
	beq     L06D0
;
; horz_button_delay <<= 1;
;
	lda     _horz_button_delay
	asl     a
	sta     _horz_button_delay
;
; old_x = cur_block.x;
;
L06D0:	lda     _cur_block
	sta     _old_x
;
; cur_block.x += 1;
;
	inc     _cur_block
;
; else if (((pad1 & PAD_LEFT) && horz_button_delay == 0) || pad1_new & PAD_LEFT)
;
	jmp     L06DA
L06D1:	lda     _pad1
	and     #$02
	beq     L06D5
	lda     _horz_button_delay
	beq     L06D8
L06D5:	lda     _pad1_new
	and     #$02
	beq     L06DA
;
; horz_button_delay = button_delay;
;
L06D8:	lda     _button_delay
	sta     _horz_button_delay
;
; if ((pad1_new & PAD_LEFT))
;
	lda     _pad1_new
	and     #$02
	beq     L06D9
;
; horz_button_delay <<= 1;
;
	lda     _horz_button_delay
	asl     a
	sta     _horz_button_delay
;
; old_x = cur_block.x;
;
L06D9:	lda     _cur_block
	sta     _old_x
;
; cur_block.x -= 1; // note: wrap around
;
	dec     _cur_block
;
; if (cur_block.x != old_x && is_cluster_colliding())
;
L06DA:	lda     _old_x
	cmp     _cur_block
	beq     L06DC
	jsr     _is_cluster_colliding
	tax
	beq     L06DC
;
; cur_block.x = old_x;
;
	lda     _old_x
	sta     _cur_block
;
; temp_fall_rate = fall_rate;
;
L06DC:	lda     _fall_rate
	sta     _temp_fall_rate
;
; if (pad1_new & PAD_DOWN)
;
	lda     _pad1_new
	and     #$04
	beq     L06DD
;
; require_new_down_button = 0;
;
	lda     #$00
	sta     _require_new_down_button
;
; temp_fall_rate = fall_frame_counter;
;
	lda     _fall_frame_counter
;
; else if ((pad1 & PAD_DOWN) && require_new_down_button == 0)
;
	jmp     L06C6
L06DD:	lda     _pad1
	and     #$04
	beq     L06E1
	lda     _require_new_down_button
	bne     L06E1
;
; temp_fall_rate >>= 4;
;
	lda     _temp_fall_rate
	lsr     a
	lsr     a
	lsr     a
	lsr     a
L06C6:	sta     _temp_fall_rate
;
; if (fall_frame_counter % temp_fall_rate == 0 || temp_fall_rate == 0)
;
L06E1:	lda     _fall_frame_counter
	jsr     pusha0
	lda     _temp_fall_rate
	jsr     tosumoda0
	cpx     #$00
	bne     L0455
	cmp     #$00
	bne     L0455
;
; cur_block.y += 1;
;
L06D9:	inc     _cur_block+1
;
; hit = 0;
;
L0455:	lda     #$00
	sta     _hit
;
; if (is_cluster_colliding())
;
	jsr     _is_cluster_colliding
	tax
	beq     L045C
;
; cur_block.y -= 1;
;
	dec     _cur_block+1
;
; hit = 1;
;
	lda     #$01
	sta     _hit
;
; if (hit)
;
L045C:	lda     _hit
	beq     L0462
;
; put_cur_cluster();
;
	jsr     _put_cur_cluster
;
; spawn_new_cluster();
;
	jmp     _spawn_new_cluster
;
; }
;
L0462:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ set_block (unsigned char, unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_set_block: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; if (y <= BOARD_OOB_END)
;
	jsr     decsp2
	ldy     #$03
	lda     (sp),y
	cmp     #$04
;
; return;
;
	bcc     L0466
;
; address = get_ppu_addr(cur_nt, (x << 3) + BOARD_START_X_PX, (y << 3) + BOARD_START_Y_PX);
;
	jsr     decsp2
	lda     _cur_nt
	ldy     #$01
	sta     (sp),y
	ldy     #$06
	lda     (sp),y
	asl     a
	asl     a
	asl     a
	clc
	adc     #$60
	ldy     #$00
	sta     (sp),y
	ldy     #$05
	lda     (sp),y
	asl     a
	asl     a
	asl     a
	jsr     _get_ppu_addr
	jsr     stax0sp
;
; one_vram_buffer(id, address); 
;
	ldy     #$02
	lda     (sp),y
	jsr     pusha
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _one_vram_buffer
;
; game_board[TILE_TO_BOARD_INDEX(x,y)] = id;
;
	ldy     #$03
	ldx     #$00
	lda     (sp),y
	jsr     mulax10
	sta     ptr1
	stx     ptr1+1
	iny
	lda     (sp),y
	clc
	adc     ptr1
	ldx     ptr1+1
	bcc     L06E3
	inx
	clc
L06E3:	adc     #<(_game_board)
	sta     ptr1
	txa
	adc     #>(_game_board)
	sta     ptr1+1
	ldy     #$02
	lda     (sp),y
	ldy     #$00
	sta     (ptr1),y
;
; }
;
L0466:	jmp     incsp5

.endproc

; ---------------------------------------------------------------
; void __near__ set_block_nt (unsigned char, unsigned char, unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_set_block_nt: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; if (y <= BOARD_OOB_END)
;
	jsr     decsp2
	ldy     #$04
	lda     (sp),y
	cmp     #$04
;
; return;
;
	bcc     L047B
;
; address = get_ppu_addr(nt, (x << 3) + BOARD_START_X_PX, (y << 3) + BOARD_START_Y_PX);
;
	jsr     decsp2
	lda     (sp),y
	ldy     #$01
	sta     (sp),y
	ldy     #$07
	lda     (sp),y
	asl     a
	asl     a
	asl     a
	clc
	adc     #$60
	ldy     #$00
	sta     (sp),y
	ldy     #$06
	lda     (sp),y
	asl     a
	asl     a
	asl     a
	jsr     _get_ppu_addr
	jsr     stax0sp
;
; one_vram_buffer(id, address);
;
	ldy     #$03
	lda     (sp),y
	jsr     pusha
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _one_vram_buffer
;
; game_board[TILE_TO_BOARD_INDEX(x,y)] = id;
;
	ldy     #$04
	ldx     #$00
	lda     (sp),y
	jsr     mulax10
	sta     ptr1
	stx     ptr1+1
	iny
	lda     (sp),y
	clc
	adc     ptr1
	ldx     ptr1+1
	bcc     L06E5
	inx
	clc
L06E5:	adc     #<(_game_board)
	sta     ptr1
	txa
	adc     #>(_game_board)
	sta     ptr1+1
	ldy     #$03
	lda     (sp),y
	ldy     #$00
	sta     (ptr1),y
;
; }
;
L047B:	jmp     incsp6

.endproc

; ---------------------------------------------------------------
; void __near__ clear_block (unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_clear_block: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; set_block(x, y, 0);
;
	jsr     decsp2
	ldy     #$03
	lda     (sp),y
	ldy     #$01
	sta     (sp),y
	iny
	lda     (sp),y
	ldy     #$00
	sta     (sp),y
	tya
	jsr     _set_block
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ put_cur_cluster (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_put_cur_cluster: near

.segment	"CODE"

;
; max_y = 0;
;
	jsr     decsp2
	lda     #$00
	sta     _max_y
;
; min_y = 0xff; // max
;
	lda     #$FF
	sta     _min_y
;
; for (iy = 0; iy < 4; ++iy)
;
	lda     #$00
	tay
L06ED:	sta     (sp),y
	cmp     #$04
	jcs     L06EE
;
; for (ix = 0; ix < 4; ++ix)
;
	tya
	iny
L06EC:	sta     (sp),y
	cmp     #$04
	jcs     L049C
;
; unsigned char bit = ((iy * 4) + (ix & 3)); // &3 = %4
;
	dey
	lda     (sp),y
	asl     a
	asl     a
	sta     ptr1
	iny
	lda     (sp),y
	and     #$03
	clc
	adc     ptr1
	jsr     pusha
;
; if (cur_cluster.layout & (0x8000 >> bit))
;
	ldy     #$00
	lda     (sp),y
	tay
	lda     #$00
	ldx     #$80
	jsr     shraxy
	and     _cur_cluster
	pha
	txa
	and     _cur_cluster+1
	sta     tmp1
	pla
	ora     tmp1
	beq     L04AE
;
; if (cur_block.y + iy < min_y)
;
	ldx     #$00
	ldy     #$01
	lda     (sp),y
	clc
	adc     _cur_block+1
	bcc     L06E6
	inx
L06E6:	cmp     _min_y
	txa
	sbc     #$00
	bcs     L04B1
;
; min_y = cur_block.y + iy;
;
	lda     (sp),y
	clc
	adc     _cur_block+1
	sta     _min_y
;
; if (cur_block.y + iy > max_y)
;
L04B1:	ldx     #$00
	lda     (sp),y
	clc
	adc     _cur_block+1
	bcc     L06E8
	inx
L06E8:	sec
	sbc     _max_y
	sta     tmp1
	txa
	sbc     #$00
	ora     tmp1
	bcc     L04B5
	beq     L04B5
;
; max_y = cur_block.y + iy;
;
	lda     (sp),y
	clc
	adc     _cur_block+1
	sta     _max_y
;
; set_block(cur_block.x + ix, cur_block.y + iy, cur_cluster.sprite);
;
L04B5:	jsr     decsp2
	ldy     #$04
	lda     (sp),y
	clc
	adc     _cur_block
	ldy     #$01
	sta     (sp),y
	ldy     #$03
	lda     (sp),y
	clc
	adc     _cur_block+1
	ldy     #$00
	sta     (sp),y
	lda     _cur_cluster+4
	jsr     _set_block
;
; }
;
L04AE:	jsr     incsp1
;
; for (ix = 0; ix < 4; ++ix)
;
	ldy     #$01
	clc
	tya
	adc     (sp),y
	jmp     L06EC
;
; for (iy = 0; iy < 4; ++iy)
;
L049C:	dey
	clc
	lda     #$01
	adc     (sp),y
	jmp     L06ED
;
; if (min_y <= BOARD_OOB_END)
;
L06EE:	lda     _min_y
	cmp     #$04
	bcs     L06EF
;
; go_to_state(STATE_OVER);
;
	lda     #$02
	jsr     _go_to_state
;
; return;
;
	jmp     incsp2
;
; cur_block.y = 255;
;
L06EF:	lda     #$FF
	sta     _cur_block+1
;
; draw_sprites();
;
	jsr     _draw_sprites
;
; try_collapse_board_data(max_y);
;
	lda     _max_y
	jsr     _try_collapse_board_data
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ get_block (unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_get_block: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; return game_board[TILE_TO_BOARD_INDEX(x,y)];
;
	ldx     #$00
	lda     (sp,x)
	jsr     mulax10
	sta     ptr1
	stx     ptr1+1
	ldy     #$01
	lda     (sp),y
	clc
	adc     ptr1
	ldx     ptr1+1
	bcc     L06F1
	inx
L06F1:	sta     ptr1
	txa
	clc
	adc     #>(_game_board)
	sta     ptr1+1
	ldy     #<(_game_board)
	ldx     #$00
	lda     (ptr1),y
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ is_block_free (unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_is_block_free: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; if (y > BOARD_END_Y_PX_BOARD || x > BOARD_END_X_PX_BOARD)
;
	ldy     #$00
	lda     (sp),y
	cmp     #$18
	bcs     L06F2
	iny
	lda     (sp),y
	cmp     #$0A
	bcc     L06F3
;
; return 0;
;
L06F2:	ldx     #$00
	txa
	jmp     incsp2
;
; return get_block(x, y) == 0;
;
L06F3:	lda     (sp),y
	jsr     pusha
	ldy     #$01
	lda     (sp),y
	jsr     _get_block
	cmp     #$00
	jsr     booleq
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ is_cluster_colliding (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_is_cluster_colliding: near

.segment	"CODE"

;
; for (iy = 0; iy < 4; ++iy)
;
	jsr     decsp2
	lda     #$00
	tay
L06F7:	sta     (sp),y
	ldx     #$00
	lda     (sp),y
	cmp     #$04
	bcs     L06F8
;
; for (ix = 0; ix < 4; ++ix)
;
	txa
	iny
L06F6:	sta     (sp),y
	cmp     #$04
	bcs     L04DA
;
; unsigned char bit = ((iy * 4) + (ix & 3)); // &3 = %4
;
	dey
	lda     (sp),y
	asl     a
	asl     a
	sta     ptr1
	iny
	lda     (sp),y
	and     #$03
	clc
	adc     ptr1
	jsr     pusha
;
; if (cur_cluster.layout & (0x8000 >> bit))
;
	ldy     #$00
	lda     (sp),y
	tay
	lda     #$00
	ldx     #$80
	jsr     shraxy
	and     _cur_cluster
	pha
	txa
	and     _cur_cluster+1
	sta     tmp1
	pla
	ora     tmp1
	beq     L04EF
;
; if (!is_block_free(cur_block.x + ix, cur_block.y + iy))
;
	ldy     #$02
	lda     (sp),y
	clc
	adc     _cur_block
	jsr     pusha
	ldy     #$02
	lda     (sp),y
	clc
	adc     _cur_block+1
	jsr     _is_block_free
	tax
	bne     L04EF
;
; return 1;
;
	lda     #$01
	jsr     incsp1
	jmp     incsp2
;
; }
;
L04EF:	jsr     incsp1
;
; for (ix = 0; ix < 4; ++ix)
;
	ldy     #$01
	clc
	tya
	adc     (sp),y
	jmp     L06F6
;
; for (iy = 0; iy < 4; ++iy)
;
L04DA:	dey
	clc
	lda     #$01
	adc     (sp),y
	jmp     L06F7
;
; return 0;
;
L06F8:	txa
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ spawn_new_cluster (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_spawn_new_cluster: near

.segment	"CODE"

;
; id = 0;
;
	lda     #$00
	sta     _id
;
; require_new_down_button = 1;
;
	lda     #$01
	sta     _require_new_down_button
;
; fall_frame_counter = 0;
;
	lda     #$00
	sta     _fall_frame_counter
;
; cur_rot = 0;
;
	sta     _cur_rot
;
; cur_cluster.def = next_cluster.def;
;
	lda     _next_cluster+2
	ldx     _next_cluster+2+1
	sta     _cur_cluster+2
	stx     _cur_cluster+2+1
;
; cur_cluster.layout = cur_cluster.def[0];
;
	sta     ptr1
	stx     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	sta     _cur_cluster+1
	dey
	lda     (ptr1),y
	sta     _cur_cluster
;
; cur_cluster.sprite = next_cluster.sprite;
;
	lda     _next_cluster+4
	sta     _cur_cluster+4
;
; cur_cluster.id = next_cluster.id;
;
	lda     _next_cluster+5
	sta     _cur_cluster+5
;
; cur_block.x = 3; //(BOARD_END_Y_PX_BOARD >> 1);
;
	lda     #$03
	sta     _cur_block
;
; cur_block.y = cluster_offsets[cur_cluster.id];
;
	ldy     _cur_cluster+5
	lda     _cluster_offsets,y
	sta     _cur_block+1
;
; if (is_cluster_colliding())
;
	jsr     _is_cluster_colliding
	tax
	beq     L050D
;
; --cur_block.y;
;
	dec     _cur_block+1
;
; id = rand8() % NUM_CLUSTERS;
;
L050D:	jsr     _rand8
	jsr     pushax
	lda     #$07
	jsr     tosumoda0
	sta     _id
;
; next_cluster.id = id;
;
	sta     _next_cluster+5
;
; next_cluster.def = cluster_defs[id]; // def_z_rev_clust;
;
	ldx     #$00
	lda     _id
	asl     a
	bcc     L06FB
	inx
	clc
L06FB:	adc     #<(_cluster_defs)
	sta     ptr1
	txa
	adc     #>(_cluster_defs)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     _next_cluster+2
	stx     _next_cluster+2+1
;
; next_cluster.layout = next_cluster.def[0];
;
	sta     ptr1
	stx     ptr1+1
	iny
	lda     (ptr1),y
	sta     _next_cluster+1
	dey
	lda     (ptr1),y
	sta     _next_cluster
;
; next_cluster.sprite = cluster_sprites[id];
;
	ldy     _id
	lda     _cluster_sprites,y
	sta     _next_cluster+4
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ rotate_cur_cluster (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_rotate_cur_cluster: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; old_rot = cur_rot;
;
	jsr     decsp1
	lda     _cur_rot
	ldy     #$00
	sta     (sp),y
;
; cur_rot = (cur_rot + dir) & 3; // % 4
;
	iny
	lda     (sp),y
	clc
	adc     _cur_rot
	and     #$03
	sta     _cur_rot
;
; cur_cluster.layout = cur_cluster.def[cur_rot];
;
	ldx     #$00
	lda     _cur_rot
	asl     a
	bcc     L06FF
	inx
	clc
L06FF:	adc     _cur_cluster+2
	sta     ptr1
	txa
	adc     _cur_cluster+2+1
	sta     ptr1+1
	lda     (ptr1),y
	sta     _cur_cluster+1
	dey
	lda     (ptr1),y
	sta     _cur_cluster
;
; if (is_cluster_colliding())
;
	jsr     _is_cluster_colliding
	tax
	beq     L0527
;
; cur_rot = old_rot;
;
	ldy     #$00
	lda     (sp),y
	sta     _cur_rot
;
; cur_cluster.layout = cur_cluster.def[cur_rot];
;
	ldx     #$00
	lda     _cur_rot
	asl     a
	bcc     L0700
	inx
	clc
L0700:	adc     _cur_cluster+2
	sta     ptr1
	txa
	adc     _cur_cluster+2+1
	sta     ptr1+1
	iny
	lda     (ptr1),y
	sta     _cur_cluster+1
	dey
	lda     (ptr1),y
	sta     _cur_cluster
;
; }
;
L0527:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ go_to_state (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_go_to_state: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; fade_delay = 5;
;
	jsr     decsp5
	lda     #$05
	ldy     #$00
	sta     (sp),y
;
; switch (state)
;
	lda     _state
;
; }
;
	cmp     #$02
	bne     L0533
;
; fade_from_bright = 1;
;
	lda     #$01
	iny
	sta     (sp),y
;
; state = new_state;
;
L0533:	ldy     #$05
	lda     (sp),y
	sta     _state
;
; switch (state)
;
	lda     _state
;
; }
;
	bne     L0701
;
; }
;
	jmp     incsp6
;
; }
;
L0701:	cmp     #$01
	beq     L0540
	cmp     #$02
	jeq     L056B
	jmp     incsp6
;
; ppu_off(); // screen off
;
L0541:	jsr     _ppu_off
;
; vram_adr(NTADR_C(0,0));
;
	ldx     #$28
	lda     #$00
	jsr     _vram_adr
;
; vram_unrle(game_area);
;
	lda     #<(_game_area)
	ldx     #>(_game_area)
	jsr     _vram_unrle
;
; ppu_on_all(); // turn on screen
;
	jsr     _ppu_on_all
;
; memfill(game_board, 0, BOARD_SIZE);
;
	jsr     decsp3
	lda     #<(_game_board)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_game_board)
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	tax
	lda     #$F0
	jsr     _memfill
;
; scroll(0, 255 - 16);
;
	jsr     push0
	lda     #$EF
	jsr     _scroll
;
; display_lines_cleared();
;
	jsr     _display_lines_cleared
;
; spawn_new_cluster();
;
	jsr     _spawn_new_cluster
;
; spawn_new_cluster();
;
	jsr     _spawn_new_cluster
;
; if (fade_from_bright)
;
	ldy     #$01
	lda     (sp),y
	beq     L0556
;
; pal_bright(7);
;
	lda     #$07
	jsr     _pal_bright
;
; delay(fade_delay);
;
	ldy     #$00
	lda     (sp),y
	jsr     _delay
;
; pal_bright(6);
;
	lda     #$06
	jsr     _pal_bright
;
; delay(fade_delay);
;
	ldy     #$00
	lda     (sp),y
	jsr     _delay
;
; pal_bright(5);
;
	lda     #$05
	jsr     _pal_bright
;
; delay(fade_delay);
;
	ldy     #$00
	lda     (sp),y
	jsr     _delay
;
; pal_bright(4);
;
	lda     #$04
	jsr     _pal_bright
;
; delay(fade_delay);
;
	ldy     #$00
	lda     (sp),y
	jsr     _delay
;
; require_new_down_button = 1;
;
L0556:	lda     #$01
	sta     _require_new_down_button
;
; break;
;
	jmp     incsp6
;
; delay(60);
;
L056B:	lda     #$3C
	jsr     _delay
;
; oam_clear();
;
	jsr     _oam_clear
;
; pal_bright(5);
;
	lda     #$05
	jsr     _pal_bright
;
; delay(fade_delay);
;
	ldy     #$00
	lda     (sp),y
	jsr     _delay
;
; pal_bright(6);
;
	lda     #$06
	jsr     _pal_bright
;
; delay(fade_delay);
;
	ldy     #$00
	lda     (sp),y
	jsr     _delay
;
; pal_bright(7);
;
	lda     #$07
	jsr     _pal_bright
;
; delay(fade_delay);
;
	ldy     #$00
	lda     (sp),y
	jsr     _delay
;
; pal_bright(8);
;
	lda     #$08
	jsr     _pal_bright
;
; delay(fade_delay);
;
	ldy     #$00
	lda     (sp),y
	jsr     _delay
;
; address = get_ppu_addr(cur_nt, 96, 112);
;
	jsr     decsp2
	lda     _cur_nt
	ldy     #$01
	sta     (sp),y
	lda     #$60
	dey
	sta     (sp),y
	lda     #$70
	jsr     _get_ppu_addr
	ldy     #$03
	jsr     staxysp
;
; multi_vram_buffer_horz("GAME OVER!", 10, address);
;
	jsr     decsp3
	lda     #<(L0585)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(L0585)
	sta     (sp),y
	lda     #$0A
	ldy     #$00
	sta     (sp),y
	ldy     #$07
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _multi_vram_buffer_horz
;
; pal_bright(7);
;
	lda     #$07
	jsr     _pal_bright
;
; delay(fade_delay);
;
	ldy     #$00
	lda     (sp),y
	jsr     _delay
;
; pal_bright(6);
;
	lda     #$06
	jsr     _pal_bright
;
; delay(fade_delay);
;
	ldy     #$00
	lda     (sp),y
	jsr     _delay
;
; pal_bright(5);
;
	lda     #$05
	jsr     _pal_bright
;
; delay(fade_delay);
;
	ldy     #$00
	lda     (sp),y
	jsr     _delay
;
; pal_bright(4);
;
	lda     #$04
	jsr     _pal_bright
;
; delay(fade_delay);
;
	ldy     #$00
	lda     (sp),y
	jsr     _delay
;
; break;
;
	jmp     incsp6

.endproc

; ---------------------------------------------------------------
; void __near__ inc_lines_cleared (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_inc_lines_cleared: near

.segment	"CODE"

;
; ++lines_cleared_one;
;
	inc     _lines_cleared_one
;
; if (lines_cleared_one == 10)
;
	lda     _lines_cleared_one
	cmp     #$0A
	bne     L05A1
;
; lines_cleared_one = 0;
;
	lda     #$00
	sta     _lines_cleared_one
;
; ++lines_cleared_ten;
;
	inc     _lines_cleared_ten
;
; if (lines_cleared_ten == 10)
;
	lda     _lines_cleared_ten
	cmp     #$0A
	bne     L05A1
;
; lines_cleared_ten = 0;
;
	lda     #$00
	sta     _lines_cleared_ten
;
; ++lines_cleared_hundred;
;
	inc     _lines_cleared_hundred
;
; }
;
L05A1:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ display_lines_cleared (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_display_lines_cleared: near

.segment	"CODE"

;
; one_vram_buffer('0' + lines_cleared_hundred, get_ppu_addr(cur_nt,0,0));
;
	lda     _lines_cleared_hundred
	clc
	adc     #$30
	jsr     pusha
	jsr     decsp2
	lda     _cur_nt
	ldy     #$01
	sta     (sp),y
	lda     #$00
	dey
	sta     (sp),y
	jsr     _get_ppu_addr
	jsr     _one_vram_buffer
;
; one_vram_buffer('0' + lines_cleared_ten, get_ppu_addr(cur_nt,8,0));
;
	lda     _lines_cleared_ten
	clc
	adc     #$30
	jsr     pusha
	jsr     decsp2
	lda     _cur_nt
	ldy     #$01
	sta     (sp),y
	lda     #$08
	dey
	sta     (sp),y
	tya
	jsr     _get_ppu_addr
	jsr     _one_vram_buffer
;
; one_vram_buffer('0' + lines_cleared_one, get_ppu_addr(cur_nt,16,0));
;
	lda     _lines_cleared_one
	clc
	adc     #$30
	jsr     pusha
	jsr     decsp2
	lda     _cur_nt
	ldy     #$01
	sta     (sp),y
	lda     #$10
	dey
	sta     (sp),y
	tya
	jsr     _get_ppu_addr
	jsr     _one_vram_buffer
;
; one_vram_buffer('0' + lines_cleared_hundred, get_ppu_addr(off_nt,0,0));
;
	lda     _lines_cleared_hundred
	clc
	adc     #$30
	jsr     pusha
	jsr     decsp2
	lda     _off_nt
	ldy     #$01
	sta     (sp),y
	lda     #$00
	dey
	sta     (sp),y
	jsr     _get_ppu_addr
	jsr     _one_vram_buffer
;
; one_vram_buffer('0' + lines_cleared_ten, get_ppu_addr(off_nt,8,0));
;
	lda     _lines_cleared_ten
	clc
	adc     #$30
	jsr     pusha
	jsr     decsp2
	lda     _off_nt
	ldy     #$01
	sta     (sp),y
	lda     #$08
	dey
	sta     (sp),y
	tya
	jsr     _get_ppu_addr
	jsr     _one_vram_buffer
;
; one_vram_buffer('0' + lines_cleared_one, get_ppu_addr(off_nt,16,0));
;
	lda     _lines_cleared_one
	clc
	adc     #$30
	jsr     pusha
	jsr     decsp2
	lda     _off_nt
	ldy     #$01
	sta     (sp),y
	lda     #$10
	dey
	sta     (sp),y
	tya
	jsr     _get_ppu_addr
	jmp     _one_vram_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ try_collapse_board_data (unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_try_collapse_board_data: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; unsigned char i = 0;
;
	jsr     decsp3
	lda     #$00
	jsr     pusha
;
; memfill(lines_cleared_y, 0xff, 4);
;
	jsr     decsp3
	lda     #<(_lines_cleared_y)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_lines_cleared_y)
	sta     (sp),y
	lda     #$FF
	ldy     #$00
	sta     (sp),y
	ldx     #$00
	lda     #$04
	jsr     _memfill
;
; for (iy = start_y; iy > BOARD_OOB_END; --iy)
;
	ldy     #$04
	lda     (sp),y
	ldy     #$02
L0703:	sta     (sp),y
	cmp     #$04
	jcc     L05D8
;
; line_complete = 1;
;
	lda     #$01
	dey
	sta     (sp),y
;
; for (ix = 0; ix <= BOARD_END_X_PX_BOARD; ++ix)
;
	lda     #$00
	ldy     #$03
L0702:	sta     (sp),y
	cmp     #$0A
	bcs     L05E2
;
; if (is_block_free(ix, iy))
;
	lda     (sp),y
	jsr     pusha
	ldy     #$03
	lda     (sp),y
	jsr     _is_block_free
	tax
	beq     L05E3
;
; line_complete = 0;
;
	lda     #$00
	ldy     #$01
	sta     (sp),y
;
; break;
;
	jmp     L0704
;
; for (ix = 0; ix <= BOARD_END_X_PX_BOARD; ++ix)
;
L05E3:	ldy     #$03
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0702
;
; if (line_complete)
;
L05E2:	ldy     #$01
L0704:	lda     (sp),y
	beq     L05D9
;
; inc_lines_cleared();
;
	jsr     _inc_lines_cleared
;
; display_lines_cleared();
;
	jsr     _display_lines_cleared
;
; memcpy(&game_board[TILE_TO_BOARD_INDEX(0, iy)], empty_row, 10);
;
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	jsr     mulax10
	clc
	adc     #<(_game_board)
	tay
	txa
	adc     #>(_game_board)
	tax
	tya
	jsr     pushax
	lda     #<(_empty_row)
	ldx     #>(_empty_row)
	jsr     pushax
	ldx     #$00
	lda     #$0A
	jsr     _memcpy
;
; lines_cleared_y[i] = iy;
;
	ldy     #$00
	lda     (sp),y
	tax
	ldy     #$02
	lda     (sp),y
	sta     _lines_cleared_y,x
;
; ++i;
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
;
; for (iy = start_y; iy > BOARD_OOB_END; --iy)
;
L05D9:	ldy     #$02
	lda     (sp),y
	sec
	sbc     #$01
	jmp     L0703
;
; if (i > 0)
;
L05D8:	ldy     #$00
	lda     (sp),y
	beq     L0601
;
; debug_display_number(lines_cleared_y[0], 6);
;
	lda     _lines_cleared_y
	jsr     pusha
	lda     #$06
	jsr     _debug_display_number
;
; reveal_empty_rows_to_nt();
;
	jsr     _reveal_empty_rows_to_nt
;
; }
;
L0601:	jmp     incsp5

.endproc

; ---------------------------------------------------------------
; void __near__ try_collapse_empty_row_data (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_try_collapse_empty_row_data: near

.segment	"CODE"

;
; for (i = 3; i >= 0; --i)
;
	jsr     decsp2
	lda     #$03
	ldy     #$00
	sta     (sp),y
L0706:	lda     (sp),y
	tax
	bmi     L060A
;
; iy = lines_cleared_y[i];
;
	lda     (sp),y
	tay
	lda     _lines_cleared_y,y
	ldy     #$01
	sta     (sp),y
;
; if (iy != 0xff)
;
	cmp     #$FF
	beq     L060B
;
; debug_display_number(iy, i);
;
	lda     (sp),y
	jsr     pusha
	ldy     #$01
	lda     (sp),y
	jsr     _debug_display_number
;
; memcpy(game_board_temp, game_board, sizeof(game_board));
;
	ldy     #$00
L0622:	lda     _game_board,y
	sta     _game_board_temp,y
	iny
	cpy     #$F0
	bne     L0622
;
; memcpy(&game_board[10], game_board_temp, iy * 10);
;
	lda     #<(_game_board+10)
	ldx     #>(_game_board+10)
	jsr     pushax
	lda     #<(_game_board_temp)
	ldx     #>(_game_board_temp)
	jsr     pushax
	ldy     #$05
	ldx     #$00
	lda     (sp),y
	jsr     mulax10
	jsr     _memcpy
;
; for (i = 3; i >= 0; --i)
;
L060B:	ldy     #$00
	lda     (sp),y
	sec
	sbc     #$01
	sta     (sp),y
	bpl     L0706
	jmp     L0706
;
; copy_board_to_nt();
;
L060A:	jsr     _copy_board_to_nt
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ reveal_empty_rows_to_nt (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_reveal_empty_rows_to_nt: near

.segment	"CODE"

;
; signed char ix = 4;
;
	lda     #$04
	jsr     pusha
;
; delay(1);
;
	jsr     decsp1
	lda     #$01
	jsr     _delay
;
; clear_vram_buffer(); 
;
	jsr     _clear_vram_buffer
;
; for (; ix >= 0; --ix)
;
	ldy     #$01
L070C:	lda     (sp),y
	tax
	jmi     L062F
;
; for (iy = 0; iy < BOARD_HEIGHT; ++iy)
;
	lda     #$00
	dey
L0707:	sta     (sp),y
	cmp     #$14
	bcs     L0637
;
; copy_board_data[iy] = game_board[TILE_TO_BOARD_INDEX(ix, iy + BOARD_OOB_END + 1)];
;
	lda     #<(_copy_board_data)
	ldx     #>(_copy_board_data)
	clc
	adc     (sp),y
	bcc     L0641
	inx
L0641:	jsr     pushax
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	clc
	adc     #$03
	bcc     L0709
	inx
	clc
L0709:	adc     #$01
	bcc     L0648
	inx
L0648:	jsr     mulax10
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	iny
	lda     (sp),y
	bpl     L064A
	dex
L064A:	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_game_board)
	sta     ptr1+1
	ldy     #<(_game_board)
	lda     (ptr1),y
	ldy     #$00
	jsr     staspidx
;
; for (iy = 0; iy < BOARD_HEIGHT; ++iy)
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0707
;
; copy_board_data, 
;
L0637:	jsr     decsp3
	lda     #<(_copy_board_data)
	iny
	sta     (sp),y
	iny
	lda     #>(_copy_board_data)
	sta     (sp),y
;
; BOARD_HEIGHT, 
;
	lda     #$14
	ldy     #$00
	sta     (sp),y
;
; cur_nt, 
;
	jsr     decsp2
	lda     _cur_nt
	iny
	sta     (sp),y
;
; BOARD_START_X_PX + (ix << 3), 
;
	ldy     #$06
	lda     (sp),y
	asl     a
	asl     a
	asl     a
	clc
	adc     #$60
	ldy     #$00
	sta     (sp),y
;
; BOARD_START_Y_PX + ((BOARD_OOB_END + 1) << 3)));
;
	lda     #$20
	jsr     _get_ppu_addr
	jsr     _multi_vram_buffer_vert
;
; for (iy = 0; iy < BOARD_HEIGHT; ++iy)
;
	lda     #$00
	tay
L0708:	sta     (sp),y
	cmp     #$14
	bcs     L0659
;
; copy_board_data[iy] = game_board[TILE_TO_BOARD_INDEX(BOARD_END_X_PX_BOARD - ix, iy + BOARD_OOB_END + 1)];
;
	lda     #<(_copy_board_data)
	ldx     #>(_copy_board_data)
	clc
	adc     (sp),y
	bcc     L0663
	inx
L0663:	jsr     pushax
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	clc
	adc     #$03
	bcc     L070A
	inx
	clc
L070A:	adc     #$01
	bcc     L066A
	inx
L066A:	jsr     mulax10
	jsr     pushax
	lda     #$09
	jsr     pusha0
	ldy     #$07
	lda     (sp),y
	bpl     L066C
	ldx     #$FF
L066C:	jsr     tossubax
	jsr     tosaddax
	sta     ptr1
	txa
	clc
	adc     #>(_game_board)
	sta     ptr1+1
	ldy     #<(_game_board)
	lda     (ptr1),y
	ldy     #$00
	jsr     staspidx
;
; for (iy = 0; iy < BOARD_HEIGHT; ++iy)
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0708
;
; copy_board_data, 
;
L0659:	jsr     decsp3
	lda     #<(_copy_board_data)
	iny
	sta     (sp),y
	iny
	lda     #>(_copy_board_data)
	sta     (sp),y
;
; BOARD_HEIGHT, 
;
	lda     #$14
	ldy     #$00
	sta     (sp),y
;
; cur_nt, 
;
	jsr     decsp2
	lda     _cur_nt
	iny
	sta     (sp),y
;
; BOARD_START_X_PX + ((BOARD_END_X_PX_BOARD - ix) << 3), 
;
	lda     #$09
	jsr     pusha0
	ldy     #$08
	lda     (sp),y
	bpl     L0676
	ldx     #$FF
L0676:	jsr     tossubax
	asl     a
	asl     a
	asl     a
	clc
	adc     #$60
	ldy     #$00
	sta     (sp),y
;
; BOARD_START_Y_PX + ((BOARD_OOB_END + 1) << 3)));    
;
	lda     #$20
	jsr     _get_ppu_addr
	jsr     _multi_vram_buffer_vert
;
; delay(5);
;
	lda     #$05
	jsr     _delay
;
; clear_vram_buffer();    
;
	jsr     _clear_vram_buffer
;
; for (; ix >= 0; --ix)
;
	ldy     #$01
	lda     (sp),y
	sec
	sbc     #$01
	sta     (sp),y
	jpl     L070C
	jmp     L070C
;
; try_collapse_empty_row_data();
;
L062F:	jsr     _try_collapse_empty_row_data
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ copy_board_to_nt (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_copy_board_to_nt: near

.segment	"CODE"

;
; delay(1);
;
	jsr     decsp2
	lda     #$01
	jsr     _delay
;
; clear_vram_buffer(); 
;
	jsr     _clear_vram_buffer
;
; for (ix = 0; ix <= BOARD_END_X_PX_BOARD; ++ix)
;
	lda     #$00
	ldy     #$01
L070F:	sta     (sp),y
	cmp     #$0A
	bcc     L0713
;
; }
;
	jmp     incsp2
;
; for (iy = 0; iy < BOARD_HEIGHT; ++iy)
;
L0713:	lda     #$00
	dey
L070E:	sta     (sp),y
	cmp     #$14
	bcs     L068C
;
; copy_board_data[iy] = game_board[TILE_TO_BOARD_INDEX(ix, iy + BOARD_OOB_END + 1)];
;
	lda     #<(_copy_board_data)
	ldx     #>(_copy_board_data)
	clc
	adc     (sp),y
	bcc     L0696
	inx
L0696:	jsr     pushax
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	clc
	adc     #$03
	bcc     L0710
	inx
	clc
L0710:	adc     #$01
	bcc     L069D
	inx
L069D:	jsr     mulax10
	sta     ptr1
	stx     ptr1+1
	iny
	lda     (sp),y
	clc
	adc     ptr1
	ldx     ptr1+1
	bcc     L070D
	inx
L070D:	sta     ptr1
	txa
	clc
	adc     #>(_game_board)
	sta     ptr1+1
	ldy     #<(_game_board)
	lda     (ptr1),y
	ldy     #$00
	jsr     staspidx
;
; for (iy = 0; iy < BOARD_HEIGHT; ++iy)
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	jmp     L070E
;
; copy_board_data, 
;
L068C:	jsr     decsp3
	lda     #<(_copy_board_data)
	iny
	sta     (sp),y
	iny
	lda     #>(_copy_board_data)
	sta     (sp),y
;
; BOARD_HEIGHT, 
;
	lda     #$14
	ldy     #$00
	sta     (sp),y
;
; cur_nt, 
;
	jsr     decsp2
	lda     _cur_nt
	iny
	sta     (sp),y
;
; BOARD_START_X_PX + (ix << 3), 
;
	ldy     #$06
	lda     (sp),y
	asl     a
	asl     a
	asl     a
	clc
	adc     #$60
	ldy     #$00
	sta     (sp),y
;
; BOARD_START_Y_PX + ((BOARD_OOB_END + 1) << 3)));
;
	lda     #$20
	jsr     _get_ppu_addr
	jsr     _multi_vram_buffer_vert
;
; if (ix % 4 == 0)
;
	ldy     #$01
	lda     (sp),y
	and     #$03
	bne     L0712
;
; delay(1);
;
	tya
	jsr     _delay
;
; clear_vram_buffer();    
;
	jsr     _clear_vram_buffer
;
; for (ix = 0; ix <= BOARD_END_X_PX_BOARD; ++ix)
;
	ldy     #$01
L0712:	clc
	tya
	adc     (sp),y
	jmp     L070F

.endproc

; ---------------------------------------------------------------
; void __near__ debug_fill_nametables (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_debug_fill_nametables: near

.segment	"CODE"

;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ debug_draw_board_area (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_debug_draw_board_area: near

.segment	"CODE"

;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ debug_copy_board_data_to_nt (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_debug_copy_board_data_to_nt: near

.segment	"CODE"

;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ debug_display_number (unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_debug_display_number: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; ppu_off(); // screen off
;
	jsr     _ppu_off
;
; pal_bg(palette_bg);
;
	lda     #<(_palette_bg)
	ldx     #>(_palette_bg)
	jsr     _pal_bg
;
; pal_spr(palette_sp);
;
	lda     #<(_palette_sp)
	ldx     #>(_palette_sp)
	jsr     _pal_spr
;
; bank_spr(1);
;
	lda     #$01
	jsr     _bank_spr
;
; set_vram_buffer(); // do at least once, sets a pointer to a buffer
;
	jsr     _set_vram_buffer
;
; clear_vram_buffer();
;
	jsr     _clear_vram_buffer
;
; off_nt = 0;
;
	lda     #$00
	sta     _off_nt
;
; cur_nt = 2;
;
	lda     #$02
	sta     _cur_nt
;
; vram_adr(NTADR_A(16-(sizeof(text)>>1),20));
;
	ldx     #$22
	lda     #$88
	jsr     _vram_adr
;
; vram_write(text, sizeof(text)-1); // -1 null term
;
	lda     #<(_text)
	ldx     #>(_text)
	jsr     pushax
	ldx     #$00
	lda     #$0F
	jsr     _vram_write
;
; scroll(0, 0x1df); // shift the bg down 1 pixel
;
	jsr     push0
	ldx     #$01
	lda     #$DF
	jsr     _scroll
;
; ppu_on_all(); // turn on screen
;
	jsr     _ppu_on_all
;
; ppu_wait_nmi(); // wait till beginning of the frame
;
L0394:	jsr     _ppu_wait_nmi
;
; tick_count++;
;
	inc     _tick_count
;
; pad1 = pad_poll(0); // read the first controller
;
	lda     #$00
	jsr     _pad_poll
	sta     _pad1
;
; pad1_new = get_pad_new(0); // newly pressed button. do pad_poll first
;
	lda     #$00
	jsr     _get_pad_new
	sta     _pad1_new
;
; clear_vram_buffer(); // do at the beginning of each frame
;
	jsr     _clear_vram_buffer
;
; switch(state)
;
	lda     _state
;
; }
;
	beq     L0714
	cmp     #$01
	beq     L03AC
	cmp     #$02
	beq     L0715
	jmp     L0394
;
; if (pad1_new & PAD_START)
;
L0714:	lda     _pad1_new
	and     #$10
	beq     L0394
;
; seed_rng();
;
	jsr     _seed_rng
;
; go_to_state(STATE_GAME);
;
	lda     #$01
	jsr     _go_to_state
;
; break;
;
	jmp     L0394
;
; movement();
;
L03AC:	jsr     _movement
;
; draw_sprites();
;
	jsr     _draw_sprites
;
; break;
;
	jmp     L0394
;
; if (pad1_new & PAD_START)
;
L0715:	lda     _pad1_new
	and     #$10
	beq     L0394
;
; go_to_state(STATE_GAME);
;
	lda     #$01
	jsr     _go_to_state
;
; break;
;
	jmp     L0394

.endproc

